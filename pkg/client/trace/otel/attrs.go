package otel

import (
	"context"
	"errors"
	"net"
	"net/http"
	"net/url"
	"reflect"
	"sort"
	"strings"

	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/semconv/v1.18.0/httpconv"

	"github.com/keboola/go-client/pkg/request"
)

const (
	maskedAttrValue    = "****"
	maskedURLPart      = "...."
	attrDefHeader      = "definition.header."
	attrDefPathParam   = "definition.params.path."
	attrDefQueryParam  = "definition.params.query."
	attrQueryParam     = "http.query."
	attrRequestHeader  = "http.header."
	attrResponseHeader = "http.response.header."
)

type attributes struct {
	config        config
	definitionURL *url.URL
	httpURL       *url.URL
	// definition attributes for span and metrics
	definition []attribute.KeyValue
	// definitionExtra attributes for span only
	definitionExtra []attribute.KeyValue
	// httpRequest attributes for span and metrics
	httpRequest []attribute.KeyValue
	// httpRequestExtra attributes for span only
	httpRequestExtra []attribute.KeyValue
	// httpResponse attributes for span and metrics
	httpResponse []attribute.KeyValue
	// httpResponseExtra attributes for span only
	httpResponseExtra []attribute.KeyValue
	// httpResponseError attributes for metrics
	httpResponseError  []attribute.KeyValue
	redactedPathValues []string
}

func newAttributes(cfg config, reqDef request.HTTPRequest) *attributes {
	out := &attributes{config: cfg}
	reqURL := reqDef.URL()

	// Result type
	var resultType string
	if v := reflect.TypeOf(reqDef.ResultDef()); v != nil {
		resultType = v.String()
	}

	// Headers
	var headerAttrs []attribute.KeyValue
	{
		for k, v := range reqDef.RequestHeader() {
			value := strings.Join(v, ";")
			if _, found := cfg.redactedHeaders[strings.ToLower(k)]; found {
				value = maskedAttrValue
			}
			headerAttrs = append(headerAttrs, attribute.String(attrDefHeader+k, value))
		}
		sort.SliceStable(headerAttrs, func(i, j int) bool {
			return headerAttrs[i].Key < headerAttrs[j].Key
		})
		out.definitionExtra = append(out.definitionExtra, headerAttrs...)
	}

	// Query params
	var queryAttrs []attribute.KeyValue
	{
		for key, values := range reqDef.QueryParams() {
			value := strings.Join(values, ";")
			if _, found := cfg.redactedQueryParams[strings.ToLower(key)]; found {
				value = maskedAttrValue
			}
			queryAttrs = append(queryAttrs, attribute.String(attrDefQueryParam+key, value))
		}
		sort.SliceStable(queryAttrs, func(i, j int) bool {
			return queryAttrs[i].Key < queryAttrs[j].Key
		})
	}

	// Path params
	var pathAttrs []attribute.KeyValue
	{
		for key, value := range reqDef.PathParams() {
			out.redactedPathValues = append(out.redactedPathValues, value)
			if _, found := cfg.redactedPathParams[strings.ToLower(key)]; found {
				value = maskedAttrValue
				reqURL.Path = strings.ReplaceAll(reqURL.Path, value, maskedURLPart)
			}
			pathAttrs = append(pathAttrs, attribute.String(attrDefPathParam+key, value))
		}
		sort.SliceStable(pathAttrs, func(i, j int) bool {
			return pathAttrs[i].Key < pathAttrs[j].Key
		})
	}

	// Base
	out.definitionURL = reqURL
	out.definition = []attribute.KeyValue{
		attribute.String("definition.method", reqDef.Method()),
		attribute.String("definition.result.type", resultType),
		attribute.String("definition.url.scheme", reqURL.Scheme),
		attribute.String("definition.url.path", mustURLPathUnescape(reqURL.Path)),
		attribute.String("definition.url.full", mustURLPathUnescape(reqURL.String())),
		attribute.String("definition.url.host.full", reqURL.Host),
	}
	if dotPos := strings.IndexByte(reqURL.Host, '.'); dotPos > 0 {
		// Host parts: to trace service name (host prefix) and stack (host suffix).
		out.definition = append(out.definition,
			// Host prefix, e.g. "connection", "encryption", "scheduler" ...
			attribute.String("definition.url.host.prefix", reqURL.Host[:dotPos]),
			// Host suffix, e.g. "keboola.com"
			attribute.String("definition.url.host.suffix", strings.TrimLeft(reqURL.Host[dotPos:], ".")),
		)
	}

	// Extra
	out.definitionExtra = append(out.definitionExtra, headerAttrs...)
	out.definitionExtra = append(out.definitionExtra, pathAttrs...)
	out.definitionExtra = append(out.definitionExtra, queryAttrs...)

	return out
}

func (v *attributes) SetFromRequest(reqOriginal *http.Request) {
	if reqOriginal == nil {
		v.httpURL = nil
		v.httpRequest = nil
		v.httpRequestExtra = nil
		return
	}

	// Clone URL to use redacted query params in the URL attribute generated by the httpconv.ClientRequest call.
	reqVal := *reqOriginal
	req := &reqVal
	urlVal := *reqOriginal.URL
	reqVal.URL = &urlVal

	// Replace redacted values in the URL path
	for _, value := range v.redactedPathValues {
		req.URL.Path = strings.ReplaceAll(req.URL.Path, value, maskedURLPart)
	}

	// Query params
	var queryAttrs []attribute.KeyValue
	{
		query := req.URL.Query()
		for key, values := range query {
			value := strings.Join(values, ";")
			if _, found := v.config.redactedQueryParams[strings.ToLower(key)]; found {
				for i := range values {
					values[i] = maskedURLPart
				}
				query[key] = values
				value = maskedAttrValue
			}
			queryAttrs = append(queryAttrs, attribute.String(attrQueryParam+key, value))
		}
		sort.SliceStable(queryAttrs, func(i, j int) bool {
			return queryAttrs[i].Key < queryAttrs[j].Key
		})
		// Modify query value for the httpconv.ClientRequest call,
		// so URL attribute will be redacted too.
		req.URL.RawQuery = query.Encode()
	}

	// Headers
	var headerAttrs []attribute.KeyValue
	{
		for key, values := range req.Header {
			key = strings.ToLower(key)
			value := strings.Join(values, ";")
			if key == "user-agent" {
				// Skip, it is already present from httpconv
				continue
			}
			if _, found := v.config.redactedHeaders[key]; found {
				value = maskedAttrValue
			}
			headerAttrs = append(headerAttrs, attribute.String(attrRequestHeader+key, value))
		}
		sort.SliceStable(headerAttrs, func(i, j int) bool {
			return headerAttrs[i].Key < headerAttrs[j].Key
		})
	}

	// Base
	v.httpURL = req.URL
	v.httpRequest = httpconv.ClientRequest(req)

	// Extra
	v.httpRequestExtra = nil
	v.httpRequestExtra = append(v.httpRequestExtra, headerAttrs...)
	v.httpRequestExtra = append(v.httpRequestExtra, queryAttrs...)
}

func (v *attributes) SetFromResponse(res *http.Response, err error) {
	// Success
	if res == nil {
		v.httpResponse = nil
		v.httpResponseExtra = nil
	} else {
		// Headers
		var headerAttrs []attribute.KeyValue
		{
			for key, values := range res.Header {
				key = strings.ToLower(key)
				value := strings.Join(values, ";")
				if _, found := v.config.redactedHeaders[key]; found {
					value = maskedAttrValue
				}
				headerAttrs = append(headerAttrs, attribute.String(attrResponseHeader+key, value))
			}
			sort.SliceStable(headerAttrs, func(i, j int) bool {
				return headerAttrs[i].Key < headerAttrs[j].Key
			})
		}

		// Base
		v.httpResponse = httpconv.ClientResponse(res)

		// Extra
		v.httpResponseExtra = nil
		v.httpResponseExtra = append(v.httpResponseExtra, headerAttrs...)
	}

	// Error
	var netErr net.Error
	errors.As(err, &netErr)
	v.httpResponseError = []attribute.KeyValue{
		attribute.Bool("http.response.isSuccess", isSuccess(res, err)),
		attribute.Bool("http.response.error.has", err != nil),
		attribute.Bool("http.response.error.net", netErr != nil),
		attribute.Bool("http.response.error.timeout", netErr != nil && netErr.Timeout()),
		attribute.Bool("http.response.error.cancelled", errors.Is(err, context.Canceled)),
		attribute.Bool("http.response.error.deadline_exceeded", errors.Is(err, context.DeadlineExceeded)),
	}
}

func mustURLPathUnescape(in string) string {
	out, err := url.PathUnescape(in)
	if err != nil {
		return in
	}
	return out
}
